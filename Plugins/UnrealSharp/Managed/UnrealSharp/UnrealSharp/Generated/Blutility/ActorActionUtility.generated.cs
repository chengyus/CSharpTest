// This file is automatically generated
using UnrealSharp.Blutility;
using UnrealSharp.Engine;
using UnrealSharp.Attributes;
using UnrealSharp.Interop;
using System.DoubleNumerics;
using System.Runtime;
using System.Runtime.InteropServices;

namespace UnrealSharp.Blutility;

[UClass]
abstract public partial class ActorActionUtility : UnrealSharp.Blutility.EditorUtilityObject, IEditorUtilityExtension
{
    
    static ActorActionUtility()
    {
        IntPtr NativeClassPtr = UCoreUObjectExporter.CallGetNativeClassFromName("ActorActionUtility");
        
        
        
        IntPtr GetSupportedClass_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetSupportedClass");
        GetSupportedClass_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetSupportedClass_NativeFunction);
        GetSupportedClass_ReturnValue_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetSupportedClass_NativeFunction, "ReturnValue");
        
        
    }
    
    protected ActorActionUtility(IntPtr nativeObject) : base(nativeObject)
    {
    }
    // Function /Script/Blutility.ActorActionUtility:GetSupportedClass
    IntPtr GetSupportedClass_NativeFunction;
    static readonly int GetSupportedClass_ParamsSize;
    static readonly int GetSupportedClass_ReturnValue_Offset;
    
    [Obsolete("If you were just returning a single class add it to the SupportedClasses array (you can find it listed in the Class Defaults).  If you were doing complex logic to simulate having multiple classes act as filters, add them to the SupportedClasses array.  If you were doing 'other' logic, you'll need to do that upon action execution.")]
    [UFunction(FunctionFlags.BlueprintEvent)]
    public virtual SubclassOf<UnrealSharp.CoreUObject.Object> GetSupportedClass()
    {
        unsafe
        {
            if (GetSupportedClass_NativeFunction == IntPtr.Zero)
            {
                GetSupportedClass_NativeFunction = UClassExporter.CallGetNativeFunctionFromInstanceAndName(NativeObject, "GetSupportedClass");
            }
            byte* ParamsBufferAllocation = stackalloc byte[GetSupportedClass_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            
            UObjectExporter.CallInvokeNativeFunction(NativeObject, GetSupportedClass_NativeFunction, ParamsBuffer);
            
            SubclassOf<UnrealSharp.CoreUObject.Object> returnValue;
            returnValue = SubclassOfMarshaller<UnrealSharp.CoreUObject.Object>.FromNative(IntPtr.Add(ParamsBuffer, GetSupportedClass_ReturnValue_Offset), 0, null);
            
            return returnValue;
        }
    }
    
    //Hide implementation function from Intellisense/ReSharper
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    protected virtual SubclassOf<UnrealSharp.CoreUObject.Object> GetSupportedClass_Implementation()
    {
        return default(SubclassOf<UnrealSharp.CoreUObject.Object>);
    }
    void Invoke_GetSupportedClass(IntPtr buffer, IntPtr returnBuffer)
    {
        unsafe
        {
            SubclassOf<UnrealSharp.CoreUObject.Object> returnValue = GetSupportedClass_Implementation();
            SubclassOfMarshaller<UnrealSharp.CoreUObject.Object>.ToNative(IntPtr.Add(returnBuffer, 0), 0, null, returnValue);
        }
    }
    
    
}
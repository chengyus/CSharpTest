// This file is automatically generated
using UnrealSharp.Blutility;
using UnrealSharp.Engine;
using UnrealSharp.Attributes;
using UnrealSharp.Interop;
using System.DoubleNumerics;
using System.Runtime;
using System.Runtime.InteropServices;

namespace UnrealSharp.Blutility;

[UClass]
abstract public partial class AssetActionUtility : UnrealSharp.Blutility.EditorUtilityObject, IEditorUtilityExtension
{
    
    static AssetActionUtility()
    {
        IntPtr NativeClassPtr = UCoreUObjectExporter.CallGetNativeClassFromName("AssetActionUtility");
        
        
        
        IntPtr IsActionForBlueprints_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "IsActionForBlueprints");
        IsActionForBlueprints_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(IsActionForBlueprints_NativeFunction);
        IsActionForBlueprints_ReturnValue_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(IsActionForBlueprints_NativeFunction, "ReturnValue");
        
        IntPtr GetSupportedClass_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetSupportedClass");
        GetSupportedClass_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetSupportedClass_NativeFunction);
        GetSupportedClass_ReturnValue_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetSupportedClass_NativeFunction, "ReturnValue");
        
        
    }
    
    protected AssetActionUtility(IntPtr nativeObject) : base(nativeObject)
    {
    }
    // Function /Script/Blutility.AssetActionUtility:IsActionForBlueprints
    IntPtr IsActionForBlueprints_NativeFunction;
    static readonly int IsActionForBlueprints_ParamsSize;
    static readonly int IsActionForBlueprints_ReturnValue_Offset;
    
    [UFunction(FunctionFlags.BlueprintEvent)]
    public virtual bool IsActionForBlueprints()
    {
        unsafe
        {
            if (IsActionForBlueprints_NativeFunction == IntPtr.Zero)
            {
                IsActionForBlueprints_NativeFunction = UClassExporter.CallGetNativeFunctionFromInstanceAndName(NativeObject, "IsActionForBlueprints");
            }
            byte* ParamsBufferAllocation = stackalloc byte[IsActionForBlueprints_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            
            UObjectExporter.CallInvokeNativeFunction(NativeObject, IsActionForBlueprints_NativeFunction, ParamsBuffer);
            
            bool returnValue;
            returnValue = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, IsActionForBlueprints_ReturnValue_Offset), 0, null);
            
            return returnValue;
        }
    }
    
    //Hide implementation function from Intellisense/ReSharper
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    protected virtual bool IsActionForBlueprints_Implementation()
    {
        return default(bool);
    }
    void Invoke_IsActionForBlueprints(IntPtr buffer, IntPtr returnBuffer)
    {
        unsafe
        {
            bool returnValue = IsActionForBlueprints_Implementation();
            BoolMarshaller.ToNative(IntPtr.Add(returnBuffer, 0), 0, null, returnValue);
        }
    }
    
    // Function /Script/Blutility.AssetActionUtility:GetSupportedClass
    IntPtr GetSupportedClass_NativeFunction;
    static readonly int GetSupportedClass_ParamsSize;
    static readonly int GetSupportedClass_ReturnValue_Offset;
    
    [Obsolete("If you were just returning a single class add it to the SupportedClasses array (you can find it listed in the Class Defaults).  If you were doing complex logic to simulate having multiple classes act as filters, add them to the SupportedClasses array.  If you were doing 'other' logic, you'll need to do that upon action execution.")]
    [UFunction(FunctionFlags.BlueprintEvent)]
    public virtual SubclassOf<UnrealSharp.CoreUObject.Object> GetSupportedClass()
    {
        unsafe
        {
            if (GetSupportedClass_NativeFunction == IntPtr.Zero)
            {
                GetSupportedClass_NativeFunction = UClassExporter.CallGetNativeFunctionFromInstanceAndName(NativeObject, "GetSupportedClass");
            }
            byte* ParamsBufferAllocation = stackalloc byte[GetSupportedClass_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            
            UObjectExporter.CallInvokeNativeFunction(NativeObject, GetSupportedClass_NativeFunction, ParamsBuffer);
            
            SubclassOf<UnrealSharp.CoreUObject.Object> returnValue;
            returnValue = SubclassOfMarshaller<UnrealSharp.CoreUObject.Object>.FromNative(IntPtr.Add(ParamsBuffer, GetSupportedClass_ReturnValue_Offset), 0, null);
            
            return returnValue;
        }
    }
    
    //Hide implementation function from Intellisense/ReSharper
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    protected virtual SubclassOf<UnrealSharp.CoreUObject.Object> GetSupportedClass_Implementation()
    {
        return default(SubclassOf<UnrealSharp.CoreUObject.Object>);
    }
    void Invoke_GetSupportedClass(IntPtr buffer, IntPtr returnBuffer)
    {
        unsafe
        {
            SubclassOf<UnrealSharp.CoreUObject.Object> returnValue = GetSupportedClass_Implementation();
            SubclassOfMarshaller<UnrealSharp.CoreUObject.Object>.ToNative(IntPtr.Add(returnBuffer, 0), 0, null, returnValue);
        }
    }
    
    
}
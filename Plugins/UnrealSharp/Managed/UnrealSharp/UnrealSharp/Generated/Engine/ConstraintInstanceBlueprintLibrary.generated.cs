// This file is automatically generated
using UnrealSharp.Engine;
using UnrealSharp.Attributes;
using UnrealSharp.Interop;
using System.DoubleNumerics;
using System.Runtime;
using System.Runtime.InteropServices;

namespace UnrealSharp.Engine;

[UClass]
public partial class ConstraintInstanceBlueprintLibrary : UnrealSharp.Engine.BlueprintFunctionLibrary
{
    
    static readonly IntPtr NativeClassPtr;
    static ConstraintInstanceBlueprintLibrary()
    {
        NativeClassPtr = UCoreUObjectExporter.CallGetNativeClassFromName("ConstraintInstanceBlueprintLibrary");
        
        
        SetProjectionParams_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetProjectionParams");
        SetProjectionParams_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetProjectionParams_NativeFunction);
        SetProjectionParams_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetProjectionParams_NativeFunction, "Accessor");
        SetProjectionParams_bEnableProjection_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetProjectionParams_NativeFunction, "bEnableProjection");
        SetProjectionParams_ProjectionLinearAlpha_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetProjectionParams_NativeFunction, "ProjectionLinearAlpha");
        SetProjectionParams_ProjectionAngularAlpha_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetProjectionParams_NativeFunction, "ProjectionAngularAlpha");
        SetParentDominates_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetParentDominates");
        SetParentDominates_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetParentDominates_NativeFunction);
        SetParentDominates_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetParentDominates_NativeFunction, "Accessor");
        SetParentDominates_bParentDominates_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetParentDominates_NativeFunction, "bParentDominates");
        SetOrientationDriveTwistAndSwing_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetOrientationDriveTwistAndSwing");
        SetOrientationDriveTwistAndSwing_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetOrientationDriveTwistAndSwing_NativeFunction);
        SetOrientationDriveTwistAndSwing_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetOrientationDriveTwistAndSwing_NativeFunction, "Accessor");
        SetOrientationDriveTwistAndSwing_bEnableTwistDrive_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetOrientationDriveTwistAndSwing_NativeFunction, "bEnableTwistDrive");
        SetOrientationDriveTwistAndSwing_bEnableSwingDrive_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetOrientationDriveTwistAndSwing_NativeFunction, "bEnableSwingDrive");
        SetOrientationDriveSLERP_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetOrientationDriveSLERP");
        SetOrientationDriveSLERP_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetOrientationDriveSLERP_NativeFunction);
        SetOrientationDriveSLERP_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetOrientationDriveSLERP_NativeFunction, "Accessor");
        SetOrientationDriveSLERP_bEnableSLERP_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetOrientationDriveSLERP_NativeFunction, "bEnableSLERP");
        SetMassConditioningEnabled_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetMassConditioningEnabled");
        SetMassConditioningEnabled_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetMassConditioningEnabled_NativeFunction);
        SetMassConditioningEnabled_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetMassConditioningEnabled_NativeFunction, "Accessor");
        SetMassConditioningEnabled_bEnableMassConditioning_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetMassConditioningEnabled_NativeFunction, "bEnableMassConditioning");
        SetLinearVelocityTarget_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetLinearVelocityTarget");
        SetLinearVelocityTarget_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetLinearVelocityTarget_NativeFunction);
        SetLinearVelocityTarget_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearVelocityTarget_NativeFunction, "Accessor");
        SetLinearVelocityTarget_InVelTarget_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearVelocityTarget_NativeFunction, "InVelTarget");
        SetLinearVelocityDrive_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetLinearVelocityDrive");
        SetLinearVelocityDrive_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetLinearVelocityDrive_NativeFunction);
        SetLinearVelocityDrive_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearVelocityDrive_NativeFunction, "Accessor");
        SetLinearVelocityDrive_bEnableDriveX_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearVelocityDrive_NativeFunction, "bEnableDriveX");
        SetLinearVelocityDrive_bEnableDriveY_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearVelocityDrive_NativeFunction, "bEnableDriveY");
        SetLinearVelocityDrive_bEnableDriveZ_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearVelocityDrive_NativeFunction, "bEnableDriveZ");
        SetLinearSoftLimitParams_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetLinearSoftLimitParams");
        SetLinearSoftLimitParams_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetLinearSoftLimitParams_NativeFunction);
        SetLinearSoftLimitParams_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearSoftLimitParams_NativeFunction, "Accessor");
        SetLinearSoftLimitParams_bSoftLinearLimit_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearSoftLimitParams_NativeFunction, "bSoftLinearLimit");
        SetLinearSoftLimitParams_LinearLimitStiffness_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearSoftLimitParams_NativeFunction, "LinearLimitStiffness");
        SetLinearSoftLimitParams_LinearLimitDamping_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearSoftLimitParams_NativeFunction, "LinearLimitDamping");
        SetLinearSoftLimitParams_LinearLimitRestitution_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearSoftLimitParams_NativeFunction, "LinearLimitRestitution");
        SetLinearSoftLimitParams_LinearLimitContactDistance_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearSoftLimitParams_NativeFunction, "LinearLimitContactDistance");
        SetLinearPositionTarget_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetLinearPositionTarget");
        SetLinearPositionTarget_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetLinearPositionTarget_NativeFunction);
        SetLinearPositionTarget_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearPositionTarget_NativeFunction, "Accessor");
        SetLinearPositionTarget_InPosTarget_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearPositionTarget_NativeFunction, "InPosTarget");
        SetLinearPositionDrive_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetLinearPositionDrive");
        SetLinearPositionDrive_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetLinearPositionDrive_NativeFunction);
        SetLinearPositionDrive_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearPositionDrive_NativeFunction, "Accessor");
        SetLinearPositionDrive_bEnableDriveX_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearPositionDrive_NativeFunction, "bEnableDriveX");
        SetLinearPositionDrive_bEnableDriveY_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearPositionDrive_NativeFunction, "bEnableDriveY");
        SetLinearPositionDrive_bEnableDriveZ_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearPositionDrive_NativeFunction, "bEnableDriveZ");
        SetLinearPlasticity_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetLinearPlasticity");
        SetLinearPlasticity_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetLinearPlasticity_NativeFunction);
        SetLinearPlasticity_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearPlasticity_NativeFunction, "Accessor");
        SetLinearPlasticity_bLinearPlasticity_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearPlasticity_NativeFunction, "bLinearPlasticity");
        SetLinearPlasticity_LinearPlasticityThreshold_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearPlasticity_NativeFunction, "LinearPlasticityThreshold");
        SetLinearPlasticity_PlasticityType_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearPlasticity_NativeFunction, "PlasticityType");
        SetLinearLimits_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetLinearLimits");
        SetLinearLimits_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetLinearLimits_NativeFunction);
        SetLinearLimits_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearLimits_NativeFunction, "Accessor");
        SetLinearLimits_XMotion_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearLimits_NativeFunction, "XMotion");
        SetLinearLimits_YMotion_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearLimits_NativeFunction, "YMotion");
        SetLinearLimits_ZMotion_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearLimits_NativeFunction, "ZMotion");
        SetLinearLimits_Limit_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearLimits_NativeFunction, "Limit");
        SetLinearDriveParams_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetLinearDriveParams");
        SetLinearDriveParams_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetLinearDriveParams_NativeFunction);
        SetLinearDriveParams_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearDriveParams_NativeFunction, "Accessor");
        SetLinearDriveParams_PositionStrength_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearDriveParams_NativeFunction, "PositionStrength");
        SetLinearDriveParams_VelocityStrength_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearDriveParams_NativeFunction, "VelocityStrength");
        SetLinearDriveParams_InForceLimit_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearDriveParams_NativeFunction, "InForceLimit");
        SetLinearBreakable_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetLinearBreakable");
        SetLinearBreakable_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetLinearBreakable_NativeFunction);
        SetLinearBreakable_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearBreakable_NativeFunction, "Accessor");
        SetLinearBreakable_bLinearBreakable_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearBreakable_NativeFunction, "bLinearBreakable");
        SetLinearBreakable_LinearBreakThreshold_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetLinearBreakable_NativeFunction, "LinearBreakThreshold");
        SetDisableCollision_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetDisableCollision");
        SetDisableCollision_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetDisableCollision_NativeFunction);
        SetDisableCollision_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetDisableCollision_NativeFunction, "Accessor");
        SetDisableCollision_bDisableCollision_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetDisableCollision_NativeFunction, "bDisableCollision");
        SetContactTransferScale_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetContactTransferScale");
        SetContactTransferScale_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetContactTransferScale_NativeFunction);
        SetContactTransferScale_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetContactTransferScale_NativeFunction, "Accessor");
        SetContactTransferScale_ContactTransferScale_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetContactTransferScale_NativeFunction, "ContactTransferScale");
        SetAngularVelocityTarget_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetAngularVelocityTarget");
        SetAngularVelocityTarget_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetAngularVelocityTarget_NativeFunction);
        SetAngularVelocityTarget_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularVelocityTarget_NativeFunction, "Accessor");
        SetAngularVelocityTarget_InVelTarget_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularVelocityTarget_NativeFunction, "InVelTarget");
        SetAngularVelocityDriveTwistAndSwing_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetAngularVelocityDriveTwistAndSwing");
        SetAngularVelocityDriveTwistAndSwing_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetAngularVelocityDriveTwistAndSwing_NativeFunction);
        SetAngularVelocityDriveTwistAndSwing_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularVelocityDriveTwistAndSwing_NativeFunction, "Accessor");
        SetAngularVelocityDriveTwistAndSwing_bEnableTwistDrive_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularVelocityDriveTwistAndSwing_NativeFunction, "bEnableTwistDrive");
        SetAngularVelocityDriveTwistAndSwing_bEnableSwingDrive_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularVelocityDriveTwistAndSwing_NativeFunction, "bEnableSwingDrive");
        SetAngularVelocityDriveSLERP_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetAngularVelocityDriveSLERP");
        SetAngularVelocityDriveSLERP_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetAngularVelocityDriveSLERP_NativeFunction);
        SetAngularVelocityDriveSLERP_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularVelocityDriveSLERP_NativeFunction, "Accessor");
        SetAngularVelocityDriveSLERP_bEnableSLERP_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularVelocityDriveSLERP_NativeFunction, "bEnableSLERP");
        SetAngularSoftTwistLimitParams_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetAngularSoftTwistLimitParams");
        SetAngularSoftTwistLimitParams_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetAngularSoftTwistLimitParams_NativeFunction);
        SetAngularSoftTwistLimitParams_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularSoftTwistLimitParams_NativeFunction, "Accessor");
        SetAngularSoftTwistLimitParams_bSoftTwistLimit_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularSoftTwistLimitParams_NativeFunction, "bSoftTwistLimit");
        SetAngularSoftTwistLimitParams_TwistLimitStiffness_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularSoftTwistLimitParams_NativeFunction, "TwistLimitStiffness");
        SetAngularSoftTwistLimitParams_TwistLimitDamping_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularSoftTwistLimitParams_NativeFunction, "TwistLimitDamping");
        SetAngularSoftTwistLimitParams_TwistLimitRestitution_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularSoftTwistLimitParams_NativeFunction, "TwistLimitRestitution");
        SetAngularSoftTwistLimitParams_TwistLimitContactDistance_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularSoftTwistLimitParams_NativeFunction, "TwistLimitContactDistance");
        SetAngularSoftSwingLimitParams_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetAngularSoftSwingLimitParams");
        SetAngularSoftSwingLimitParams_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetAngularSoftSwingLimitParams_NativeFunction);
        SetAngularSoftSwingLimitParams_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularSoftSwingLimitParams_NativeFunction, "Accessor");
        SetAngularSoftSwingLimitParams_bSoftSwingLimit_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularSoftSwingLimitParams_NativeFunction, "bSoftSwingLimit");
        SetAngularSoftSwingLimitParams_SwingLimitStiffness_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularSoftSwingLimitParams_NativeFunction, "SwingLimitStiffness");
        SetAngularSoftSwingLimitParams_SwingLimitDamping_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularSoftSwingLimitParams_NativeFunction, "SwingLimitDamping");
        SetAngularSoftSwingLimitParams_SwingLimitRestitution_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularSoftSwingLimitParams_NativeFunction, "SwingLimitRestitution");
        SetAngularSoftSwingLimitParams_SwingLimitContactDistance_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularSoftSwingLimitParams_NativeFunction, "SwingLimitContactDistance");
        SetAngularPlasticity_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetAngularPlasticity");
        SetAngularPlasticity_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetAngularPlasticity_NativeFunction);
        SetAngularPlasticity_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularPlasticity_NativeFunction, "Accessor");
        SetAngularPlasticity_bAngularPlasticity_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularPlasticity_NativeFunction, "bAngularPlasticity");
        SetAngularPlasticity_AngularPlasticityThreshold_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularPlasticity_NativeFunction, "AngularPlasticityThreshold");
        SetAngularOrientationTarget_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetAngularOrientationTarget");
        SetAngularOrientationTarget_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetAngularOrientationTarget_NativeFunction);
        SetAngularOrientationTarget_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularOrientationTarget_NativeFunction, "Accessor");
        SetAngularOrientationTarget_InPosTarget_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularOrientationTarget_NativeFunction, "InPosTarget");
        SetAngularLimits_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetAngularLimits");
        SetAngularLimits_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetAngularLimits_NativeFunction);
        SetAngularLimits_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularLimits_NativeFunction, "Accessor");
        SetAngularLimits_Swing1MotionType_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularLimits_NativeFunction, "Swing1MotionType");
        SetAngularLimits_Swing1LimitAngle_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularLimits_NativeFunction, "Swing1LimitAngle");
        SetAngularLimits_Swing2MotionType_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularLimits_NativeFunction, "Swing2MotionType");
        SetAngularLimits_Swing2LimitAngle_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularLimits_NativeFunction, "Swing2LimitAngle");
        SetAngularLimits_TwistMotionType_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularLimits_NativeFunction, "TwistMotionType");
        SetAngularLimits_TwistLimitAngle_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularLimits_NativeFunction, "TwistLimitAngle");
        SetAngularDriveParams_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetAngularDriveParams");
        SetAngularDriveParams_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetAngularDriveParams_NativeFunction);
        SetAngularDriveParams_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularDriveParams_NativeFunction, "Accessor");
        SetAngularDriveParams_PositionStrength_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularDriveParams_NativeFunction, "PositionStrength");
        SetAngularDriveParams_VelocityStrength_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularDriveParams_NativeFunction, "VelocityStrength");
        SetAngularDriveParams_InForceLimit_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularDriveParams_NativeFunction, "InForceLimit");
        SetAngularDriveMode_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetAngularDriveMode");
        SetAngularDriveMode_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetAngularDriveMode_NativeFunction);
        SetAngularDriveMode_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularDriveMode_NativeFunction, "Accessor");
        SetAngularDriveMode_DriveMode_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularDriveMode_NativeFunction, "DriveMode");
        SetAngularBreakable_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "SetAngularBreakable");
        SetAngularBreakable_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(SetAngularBreakable_NativeFunction);
        SetAngularBreakable_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularBreakable_NativeFunction, "Accessor");
        SetAngularBreakable_bAngularBreakable_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularBreakable_NativeFunction, "bAngularBreakable");
        SetAngularBreakable_AngularBreakThreshold_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(SetAngularBreakable_NativeFunction, "AngularBreakThreshold");
        GetProjectionParams_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetProjectionParams");
        GetProjectionParams_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetProjectionParams_NativeFunction);
        GetProjectionParams_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetProjectionParams_NativeFunction, "Accessor");
        GetProjectionParams_bEnableProjection_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetProjectionParams_NativeFunction, "bEnableProjection");
        GetProjectionParams_ProjectionLinearAlpha_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetProjectionParams_NativeFunction, "ProjectionLinearAlpha");
        GetProjectionParams_ProjectionAngularAlpha_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetProjectionParams_NativeFunction, "ProjectionAngularAlpha");
        GetParentDominates_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetParentDominates");
        GetParentDominates_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetParentDominates_NativeFunction);
        GetParentDominates_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetParentDominates_NativeFunction, "Accessor");
        GetParentDominates_ReturnValue_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetParentDominates_NativeFunction, "ReturnValue");
        GetOrientationDriveTwistAndSwing_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetOrientationDriveTwistAndSwing");
        GetOrientationDriveTwistAndSwing_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetOrientationDriveTwistAndSwing_NativeFunction);
        GetOrientationDriveTwistAndSwing_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetOrientationDriveTwistAndSwing_NativeFunction, "Accessor");
        GetOrientationDriveTwistAndSwing_bOutEnableTwistDrive_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetOrientationDriveTwistAndSwing_NativeFunction, "bOutEnableTwistDrive");
        GetOrientationDriveTwistAndSwing_bOutEnableSwingDrive_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetOrientationDriveTwistAndSwing_NativeFunction, "bOutEnableSwingDrive");
        GetOrientationDriveSLERP_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetOrientationDriveSLERP");
        GetOrientationDriveSLERP_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetOrientationDriveSLERP_NativeFunction);
        GetOrientationDriveSLERP_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetOrientationDriveSLERP_NativeFunction, "Accessor");
        GetOrientationDriveSLERP_bOutEnableSLERP_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetOrientationDriveSLERP_NativeFunction, "bOutEnableSLERP");
        GetMassConditioningEnabled_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetMassConditioningEnabled");
        GetMassConditioningEnabled_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetMassConditioningEnabled_NativeFunction);
        GetMassConditioningEnabled_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetMassConditioningEnabled_NativeFunction, "Accessor");
        GetMassConditioningEnabled_ReturnValue_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetMassConditioningEnabled_NativeFunction, "ReturnValue");
        GetLinearVelocityTarget_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetLinearVelocityTarget");
        GetLinearVelocityTarget_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetLinearVelocityTarget_NativeFunction);
        GetLinearVelocityTarget_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearVelocityTarget_NativeFunction, "Accessor");
        GetLinearVelocityTarget_OutVelTarget_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearVelocityTarget_NativeFunction, "OutVelTarget");
        GetLinearVelocityDrive_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetLinearVelocityDrive");
        GetLinearVelocityDrive_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetLinearVelocityDrive_NativeFunction);
        GetLinearVelocityDrive_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearVelocityDrive_NativeFunction, "Accessor");
        GetLinearVelocityDrive_bOutEnableDriveX_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearVelocityDrive_NativeFunction, "bOutEnableDriveX");
        GetLinearVelocityDrive_bOutEnableDriveY_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearVelocityDrive_NativeFunction, "bOutEnableDriveY");
        GetLinearVelocityDrive_bOutEnableDriveZ_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearVelocityDrive_NativeFunction, "bOutEnableDriveZ");
        GetLinearSoftLimitParams_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetLinearSoftLimitParams");
        GetLinearSoftLimitParams_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetLinearSoftLimitParams_NativeFunction);
        GetLinearSoftLimitParams_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearSoftLimitParams_NativeFunction, "Accessor");
        GetLinearSoftLimitParams_bSoftLinearLimit_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearSoftLimitParams_NativeFunction, "bSoftLinearLimit");
        GetLinearSoftLimitParams_LinearLimitStiffness_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearSoftLimitParams_NativeFunction, "LinearLimitStiffness");
        GetLinearSoftLimitParams_LinearLimitDamping_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearSoftLimitParams_NativeFunction, "LinearLimitDamping");
        GetLinearSoftLimitParams_LinearLimitRestitution_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearSoftLimitParams_NativeFunction, "LinearLimitRestitution");
        GetLinearSoftLimitParams_LinearLimitContactDistance_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearSoftLimitParams_NativeFunction, "LinearLimitContactDistance");
        GetLinearPositionTarget_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetLinearPositionTarget");
        GetLinearPositionTarget_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetLinearPositionTarget_NativeFunction);
        GetLinearPositionTarget_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearPositionTarget_NativeFunction, "Accessor");
        GetLinearPositionTarget_OutPosTarget_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearPositionTarget_NativeFunction, "OutPosTarget");
        GetLinearPositionDrive_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetLinearPositionDrive");
        GetLinearPositionDrive_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetLinearPositionDrive_NativeFunction);
        GetLinearPositionDrive_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearPositionDrive_NativeFunction, "Accessor");
        GetLinearPositionDrive_bOutEnableDriveX_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearPositionDrive_NativeFunction, "bOutEnableDriveX");
        GetLinearPositionDrive_bOutEnableDriveY_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearPositionDrive_NativeFunction, "bOutEnableDriveY");
        GetLinearPositionDrive_bOutEnableDriveZ_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearPositionDrive_NativeFunction, "bOutEnableDriveZ");
        GetLinearPlasticity_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetLinearPlasticity");
        GetLinearPlasticity_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetLinearPlasticity_NativeFunction);
        GetLinearPlasticity_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearPlasticity_NativeFunction, "Accessor");
        GetLinearPlasticity_bLinearPlasticity_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearPlasticity_NativeFunction, "bLinearPlasticity");
        GetLinearPlasticity_LinearPlasticityThreshold_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearPlasticity_NativeFunction, "LinearPlasticityThreshold");
        GetLinearPlasticity_PlasticityType_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearPlasticity_NativeFunction, "PlasticityType");
        GetLinearLimits_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetLinearLimits");
        GetLinearLimits_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetLinearLimits_NativeFunction);
        GetLinearLimits_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearLimits_NativeFunction, "Accessor");
        GetLinearLimits_XMotion_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearLimits_NativeFunction, "XMotion");
        GetLinearLimits_YMotion_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearLimits_NativeFunction, "YMotion");
        GetLinearLimits_ZMotion_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearLimits_NativeFunction, "ZMotion");
        GetLinearLimits_Limit_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearLimits_NativeFunction, "Limit");
        GetLinearDriveParams_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetLinearDriveParams");
        GetLinearDriveParams_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetLinearDriveParams_NativeFunction);
        GetLinearDriveParams_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearDriveParams_NativeFunction, "Accessor");
        GetLinearDriveParams_OutPositionStrength_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearDriveParams_NativeFunction, "OutPositionStrength");
        GetLinearDriveParams_OutVelocityStrength_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearDriveParams_NativeFunction, "OutVelocityStrength");
        GetLinearDriveParams_OutForceLimit_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearDriveParams_NativeFunction, "OutForceLimit");
        GetLinearBreakable_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetLinearBreakable");
        GetLinearBreakable_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetLinearBreakable_NativeFunction);
        GetLinearBreakable_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearBreakable_NativeFunction, "Accessor");
        GetLinearBreakable_bLinearBreakable_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearBreakable_NativeFunction, "bLinearBreakable");
        GetLinearBreakable_LinearBreakThreshold_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetLinearBreakable_NativeFunction, "LinearBreakThreshold");
        GetDisableCollsion_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetDisableCollsion");
        GetDisableCollsion_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetDisableCollsion_NativeFunction);
        GetDisableCollsion_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetDisableCollsion_NativeFunction, "Accessor");
        GetDisableCollsion_ReturnValue_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetDisableCollsion_NativeFunction, "ReturnValue");
        GetContactTransferScale_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetContactTransferScale");
        GetContactTransferScale_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetContactTransferScale_NativeFunction);
        GetContactTransferScale_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetContactTransferScale_NativeFunction, "Accessor");
        GetContactTransferScale_ContactTransferScale_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetContactTransferScale_NativeFunction, "ContactTransferScale");
        GetAttachedBodyNames_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetAttachedBodyNames");
        GetAttachedBodyNames_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetAttachedBodyNames_NativeFunction);
        GetAttachedBodyNames_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAttachedBodyNames_NativeFunction, "Accessor");
        GetAttachedBodyNames_ParentBody_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAttachedBodyNames_NativeFunction, "ParentBody");
        GetAttachedBodyNames_ChildBody_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAttachedBodyNames_NativeFunction, "ChildBody");
        GetAngularVelocityTarget_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetAngularVelocityTarget");
        GetAngularVelocityTarget_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetAngularVelocityTarget_NativeFunction);
        GetAngularVelocityTarget_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularVelocityTarget_NativeFunction, "Accessor");
        GetAngularVelocityTarget_OutVelTarget_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularVelocityTarget_NativeFunction, "OutVelTarget");
        GetAngularVelocityDriveTwistAndSwing_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetAngularVelocityDriveTwistAndSwing");
        GetAngularVelocityDriveTwistAndSwing_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetAngularVelocityDriveTwistAndSwing_NativeFunction);
        GetAngularVelocityDriveTwistAndSwing_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularVelocityDriveTwistAndSwing_NativeFunction, "Accessor");
        GetAngularVelocityDriveTwistAndSwing_bOutEnableTwistDrive_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularVelocityDriveTwistAndSwing_NativeFunction, "bOutEnableTwistDrive");
        GetAngularVelocityDriveTwistAndSwing_bOutEnableSwingDrive_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularVelocityDriveTwistAndSwing_NativeFunction, "bOutEnableSwingDrive");
        GetAngularVelocityDriveSLERP_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetAngularVelocityDriveSLERP");
        GetAngularVelocityDriveSLERP_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetAngularVelocityDriveSLERP_NativeFunction);
        GetAngularVelocityDriveSLERP_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularVelocityDriveSLERP_NativeFunction, "Accessor");
        GetAngularVelocityDriveSLERP_bOutEnableSLERP_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularVelocityDriveSLERP_NativeFunction, "bOutEnableSLERP");
        GetAngularSoftTwistLimitParams_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetAngularSoftTwistLimitParams");
        GetAngularSoftTwistLimitParams_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetAngularSoftTwistLimitParams_NativeFunction);
        GetAngularSoftTwistLimitParams_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularSoftTwistLimitParams_NativeFunction, "Accessor");
        GetAngularSoftTwistLimitParams_bSoftTwistLimit_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularSoftTwistLimitParams_NativeFunction, "bSoftTwistLimit");
        GetAngularSoftTwistLimitParams_TwistLimitStiffness_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularSoftTwistLimitParams_NativeFunction, "TwistLimitStiffness");
        GetAngularSoftTwistLimitParams_TwistLimitDamping_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularSoftTwistLimitParams_NativeFunction, "TwistLimitDamping");
        GetAngularSoftTwistLimitParams_TwistLimitRestitution_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularSoftTwistLimitParams_NativeFunction, "TwistLimitRestitution");
        GetAngularSoftTwistLimitParams_TwistLimitContactDistance_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularSoftTwistLimitParams_NativeFunction, "TwistLimitContactDistance");
        GetAngularSoftSwingLimitParams_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetAngularSoftSwingLimitParams");
        GetAngularSoftSwingLimitParams_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetAngularSoftSwingLimitParams_NativeFunction);
        GetAngularSoftSwingLimitParams_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularSoftSwingLimitParams_NativeFunction, "Accessor");
        GetAngularSoftSwingLimitParams_bSoftSwingLimit_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularSoftSwingLimitParams_NativeFunction, "bSoftSwingLimit");
        GetAngularSoftSwingLimitParams_SwingLimitStiffness_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularSoftSwingLimitParams_NativeFunction, "SwingLimitStiffness");
        GetAngularSoftSwingLimitParams_SwingLimitDamping_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularSoftSwingLimitParams_NativeFunction, "SwingLimitDamping");
        GetAngularSoftSwingLimitParams_SwingLimitRestitution_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularSoftSwingLimitParams_NativeFunction, "SwingLimitRestitution");
        GetAngularSoftSwingLimitParams_SwingLimitContactDistance_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularSoftSwingLimitParams_NativeFunction, "SwingLimitContactDistance");
        GetAngularPlasticity_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetAngularPlasticity");
        GetAngularPlasticity_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetAngularPlasticity_NativeFunction);
        GetAngularPlasticity_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularPlasticity_NativeFunction, "Accessor");
        GetAngularPlasticity_bAngularPlasticity_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularPlasticity_NativeFunction, "bAngularPlasticity");
        GetAngularPlasticity_AngularPlasticityThreshold_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularPlasticity_NativeFunction, "AngularPlasticityThreshold");
        GetAngularOrientationTarget_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetAngularOrientationTarget");
        GetAngularOrientationTarget_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetAngularOrientationTarget_NativeFunction);
        GetAngularOrientationTarget_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularOrientationTarget_NativeFunction, "Accessor");
        GetAngularOrientationTarget_OutPosTarget_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularOrientationTarget_NativeFunction, "OutPosTarget");
        GetAngularLimits_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetAngularLimits");
        GetAngularLimits_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetAngularLimits_NativeFunction);
        GetAngularLimits_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularLimits_NativeFunction, "Accessor");
        GetAngularLimits_Swing1MotionType_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularLimits_NativeFunction, "Swing1MotionType");
        GetAngularLimits_Swing1LimitAngle_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularLimits_NativeFunction, "Swing1LimitAngle");
        GetAngularLimits_Swing2MotionType_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularLimits_NativeFunction, "Swing2MotionType");
        GetAngularLimits_Swing2LimitAngle_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularLimits_NativeFunction, "Swing2LimitAngle");
        GetAngularLimits_TwistMotionType_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularLimits_NativeFunction, "TwistMotionType");
        GetAngularLimits_TwistLimitAngle_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularLimits_NativeFunction, "TwistLimitAngle");
        GetAngularDriveParams_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetAngularDriveParams");
        GetAngularDriveParams_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetAngularDriveParams_NativeFunction);
        GetAngularDriveParams_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularDriveParams_NativeFunction, "Accessor");
        GetAngularDriveParams_OutPositionStrength_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularDriveParams_NativeFunction, "OutPositionStrength");
        GetAngularDriveParams_OutVelocityStrength_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularDriveParams_NativeFunction, "OutVelocityStrength");
        GetAngularDriveParams_OutForceLimit_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularDriveParams_NativeFunction, "OutForceLimit");
        GetAngularDriveMode_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetAngularDriveMode");
        GetAngularDriveMode_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetAngularDriveMode_NativeFunction);
        GetAngularDriveMode_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularDriveMode_NativeFunction, "Accessor");
        GetAngularDriveMode_OutDriveMode_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularDriveMode_NativeFunction, "OutDriveMode");
        GetAngularBreakable_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "GetAngularBreakable");
        GetAngularBreakable_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(GetAngularBreakable_NativeFunction);
        GetAngularBreakable_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularBreakable_NativeFunction, "Accessor");
        GetAngularBreakable_bAngularBreakable_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularBreakable_NativeFunction, "bAngularBreakable");
        GetAngularBreakable_AngularBreakThreshold_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(GetAngularBreakable_NativeFunction, "AngularBreakThreshold");
        CopyParams_NativeFunction = UClassExporter.CallGetNativeFunctionFromClassAndName(NativeClassPtr, "CopyParams");
        CopyParams_ParamsSize = UFunctionExporter.CallGetNativeFunctionParamsSize(CopyParams_NativeFunction);
        CopyParams_Accessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(CopyParams_NativeFunction, "Accessor");
        CopyParams_SourceAccessor_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(CopyParams_NativeFunction, "SourceAccessor");
        CopyParams_bKeepPosition_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(CopyParams_NativeFunction, "bKeepPosition");
        CopyParams_bKeepRotation_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(CopyParams_NativeFunction, "bKeepRotation");
        
        
    }
    
    protected ConstraintInstanceBlueprintLibrary(IntPtr nativeObject) : base(nativeObject)
    {
    }
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetProjectionParams
    static readonly IntPtr SetProjectionParams_NativeFunction;
    static readonly int SetProjectionParams_ParamsSize;
    static readonly int SetProjectionParams_Accessor_Offset;
    static readonly int SetProjectionParams_bEnableProjection_Offset;
    static readonly int SetProjectionParams_ProjectionLinearAlpha_Offset;
    static readonly int SetProjectionParams_ProjectionAngularAlpha_Offset;
    
    public static void SetProjectionParams(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bEnableProjection, float projectionLinearAlpha, float projectionAngularAlpha)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetProjectionParams_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetProjectionParams_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetProjectionParams_bEnableProjection_Offset), 0, null, bEnableProjection);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetProjectionParams_ProjectionLinearAlpha_Offset), 0, null, projectionLinearAlpha);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetProjectionParams_ProjectionAngularAlpha_Offset), 0, null, projectionAngularAlpha);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetProjectionParams_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetProjectionParams_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetParentDominates
    static readonly IntPtr SetParentDominates_NativeFunction;
    static readonly int SetParentDominates_ParamsSize;
    static readonly int SetParentDominates_Accessor_Offset;
    static readonly int SetParentDominates_bParentDominates_Offset;
    
    public static void SetParentDominates(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bParentDominates)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetParentDominates_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetParentDominates_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetParentDominates_bParentDominates_Offset), 0, null, bParentDominates);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetParentDominates_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetParentDominates_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetOrientationDriveTwistAndSwing
    static readonly IntPtr SetOrientationDriveTwistAndSwing_NativeFunction;
    static readonly int SetOrientationDriveTwistAndSwing_ParamsSize;
    static readonly int SetOrientationDriveTwistAndSwing_Accessor_Offset;
    static readonly int SetOrientationDriveTwistAndSwing_bEnableTwistDrive_Offset;
    static readonly int SetOrientationDriveTwistAndSwing_bEnableSwingDrive_Offset;
    
    public static void SetOrientationDriveTwistAndSwing(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bEnableTwistDrive, bool bEnableSwingDrive)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetOrientationDriveTwistAndSwing_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetOrientationDriveTwistAndSwing_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetOrientationDriveTwistAndSwing_bEnableTwistDrive_Offset), 0, null, bEnableTwistDrive);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetOrientationDriveTwistAndSwing_bEnableSwingDrive_Offset), 0, null, bEnableSwingDrive);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetOrientationDriveTwistAndSwing_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetOrientationDriveTwistAndSwing_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetOrientationDriveSLERP
    static readonly IntPtr SetOrientationDriveSLERP_NativeFunction;
    static readonly int SetOrientationDriveSLERP_ParamsSize;
    static readonly int SetOrientationDriveSLERP_Accessor_Offset;
    static readonly int SetOrientationDriveSLERP_bEnableSLERP_Offset;
    
    public static void SetOrientationDriveSLERP(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bEnableSLERP)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetOrientationDriveSLERP_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetOrientationDriveSLERP_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetOrientationDriveSLERP_bEnableSLERP_Offset), 0, null, bEnableSLERP);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetOrientationDriveSLERP_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetOrientationDriveSLERP_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetMassConditioningEnabled
    static readonly IntPtr SetMassConditioningEnabled_NativeFunction;
    static readonly int SetMassConditioningEnabled_ParamsSize;
    static readonly int SetMassConditioningEnabled_Accessor_Offset;
    static readonly int SetMassConditioningEnabled_bEnableMassConditioning_Offset;
    
    public static void SetMassConditioningEnabled(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bEnableMassConditioning)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetMassConditioningEnabled_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetMassConditioningEnabled_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetMassConditioningEnabled_bEnableMassConditioning_Offset), 0, null, bEnableMassConditioning);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetMassConditioningEnabled_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetMassConditioningEnabled_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetLinearVelocityTarget
    static readonly IntPtr SetLinearVelocityTarget_NativeFunction;
    static readonly int SetLinearVelocityTarget_ParamsSize;
    static readonly int SetLinearVelocityTarget_Accessor_Offset;
    static readonly int SetLinearVelocityTarget_InVelTarget_Offset;
    
    public static void SetLinearVelocityTarget(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, System.DoubleNumerics.Vector3 inVelTarget)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetLinearVelocityTarget_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetLinearVelocityTarget_Accessor_Offset), 0, null, accessor);
            BlittableMarshaller<System.DoubleNumerics.Vector3>.ToNative(IntPtr.Add(ParamsBuffer, SetLinearVelocityTarget_InVelTarget_Offset), 0, null, inVelTarget);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetLinearVelocityTarget_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetLinearVelocityTarget_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetLinearVelocityDrive
    static readonly IntPtr SetLinearVelocityDrive_NativeFunction;
    static readonly int SetLinearVelocityDrive_ParamsSize;
    static readonly int SetLinearVelocityDrive_Accessor_Offset;
    static readonly int SetLinearVelocityDrive_bEnableDriveX_Offset;
    static readonly int SetLinearVelocityDrive_bEnableDriveY_Offset;
    static readonly int SetLinearVelocityDrive_bEnableDriveZ_Offset;
    
    public static void SetLinearVelocityDrive(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetLinearVelocityDrive_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetLinearVelocityDrive_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetLinearVelocityDrive_bEnableDriveX_Offset), 0, null, bEnableDriveX);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetLinearVelocityDrive_bEnableDriveY_Offset), 0, null, bEnableDriveY);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetLinearVelocityDrive_bEnableDriveZ_Offset), 0, null, bEnableDriveZ);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetLinearVelocityDrive_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetLinearVelocityDrive_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetLinearSoftLimitParams
    static readonly IntPtr SetLinearSoftLimitParams_NativeFunction;
    static readonly int SetLinearSoftLimitParams_ParamsSize;
    static readonly int SetLinearSoftLimitParams_Accessor_Offset;
    static readonly int SetLinearSoftLimitParams_bSoftLinearLimit_Offset;
    static readonly int SetLinearSoftLimitParams_LinearLimitStiffness_Offset;
    static readonly int SetLinearSoftLimitParams_LinearLimitDamping_Offset;
    static readonly int SetLinearSoftLimitParams_LinearLimitRestitution_Offset;
    static readonly int SetLinearSoftLimitParams_LinearLimitContactDistance_Offset;
    
    public static void SetLinearSoftLimitParams(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bSoftLinearLimit, float linearLimitStiffness, float linearLimitDamping, float linearLimitRestitution, float linearLimitContactDistance)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetLinearSoftLimitParams_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetLinearSoftLimitParams_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetLinearSoftLimitParams_bSoftLinearLimit_Offset), 0, null, bSoftLinearLimit);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetLinearSoftLimitParams_LinearLimitStiffness_Offset), 0, null, linearLimitStiffness);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetLinearSoftLimitParams_LinearLimitDamping_Offset), 0, null, linearLimitDamping);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetLinearSoftLimitParams_LinearLimitRestitution_Offset), 0, null, linearLimitRestitution);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetLinearSoftLimitParams_LinearLimitContactDistance_Offset), 0, null, linearLimitContactDistance);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetLinearSoftLimitParams_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetLinearSoftLimitParams_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetLinearPositionTarget
    static readonly IntPtr SetLinearPositionTarget_NativeFunction;
    static readonly int SetLinearPositionTarget_ParamsSize;
    static readonly int SetLinearPositionTarget_Accessor_Offset;
    static readonly int SetLinearPositionTarget_InPosTarget_Offset;
    
    public static void SetLinearPositionTarget(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, System.DoubleNumerics.Vector3 inPosTarget)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetLinearPositionTarget_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetLinearPositionTarget_Accessor_Offset), 0, null, accessor);
            BlittableMarshaller<System.DoubleNumerics.Vector3>.ToNative(IntPtr.Add(ParamsBuffer, SetLinearPositionTarget_InPosTarget_Offset), 0, null, inPosTarget);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetLinearPositionTarget_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetLinearPositionTarget_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetLinearPositionDrive
    static readonly IntPtr SetLinearPositionDrive_NativeFunction;
    static readonly int SetLinearPositionDrive_ParamsSize;
    static readonly int SetLinearPositionDrive_Accessor_Offset;
    static readonly int SetLinearPositionDrive_bEnableDriveX_Offset;
    static readonly int SetLinearPositionDrive_bEnableDriveY_Offset;
    static readonly int SetLinearPositionDrive_bEnableDriveZ_Offset;
    
    public static void SetLinearPositionDrive(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetLinearPositionDrive_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetLinearPositionDrive_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetLinearPositionDrive_bEnableDriveX_Offset), 0, null, bEnableDriveX);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetLinearPositionDrive_bEnableDriveY_Offset), 0, null, bEnableDriveY);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetLinearPositionDrive_bEnableDriveZ_Offset), 0, null, bEnableDriveZ);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetLinearPositionDrive_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetLinearPositionDrive_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetLinearPlasticity
    static readonly IntPtr SetLinearPlasticity_NativeFunction;
    static readonly int SetLinearPlasticity_ParamsSize;
    static readonly int SetLinearPlasticity_Accessor_Offset;
    static readonly int SetLinearPlasticity_bLinearPlasticity_Offset;
    static readonly int SetLinearPlasticity_LinearPlasticityThreshold_Offset;
    static readonly int SetLinearPlasticity_PlasticityType_Offset;
    
    public static void SetLinearPlasticity(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bLinearPlasticity, float linearPlasticityThreshold, UnrealSharp.PhysicsCore.EConstraintPlasticityType plasticityType)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetLinearPlasticity_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetLinearPlasticity_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetLinearPlasticity_bLinearPlasticity_Offset), 0, null, bLinearPlasticity);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetLinearPlasticity_LinearPlasticityThreshold_Offset), 0, null, linearPlasticityThreshold);
            BlittableMarshaller<UnrealSharp.PhysicsCore.EConstraintPlasticityType>.ToNative(IntPtr.Add(ParamsBuffer, SetLinearPlasticity_PlasticityType_Offset), 0, null, plasticityType);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetLinearPlasticity_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetLinearPlasticity_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetLinearLimits
    static readonly IntPtr SetLinearLimits_NativeFunction;
    static readonly int SetLinearLimits_ParamsSize;
    static readonly int SetLinearLimits_Accessor_Offset;
    static readonly int SetLinearLimits_XMotion_Offset;
    static readonly int SetLinearLimits_YMotion_Offset;
    static readonly int SetLinearLimits_ZMotion_Offset;
    static readonly int SetLinearLimits_Limit_Offset;
    
    public static void SetLinearLimits(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, UnrealSharp.PhysicsCore.ELinearConstraintMotion xMotion, UnrealSharp.PhysicsCore.ELinearConstraintMotion yMotion, UnrealSharp.PhysicsCore.ELinearConstraintMotion zMotion, float limit)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetLinearLimits_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetLinearLimits_Accessor_Offset), 0, null, accessor);
            BlittableMarshaller<UnrealSharp.PhysicsCore.ELinearConstraintMotion>.ToNative(IntPtr.Add(ParamsBuffer, SetLinearLimits_XMotion_Offset), 0, null, xMotion);
            BlittableMarshaller<UnrealSharp.PhysicsCore.ELinearConstraintMotion>.ToNative(IntPtr.Add(ParamsBuffer, SetLinearLimits_YMotion_Offset), 0, null, yMotion);
            BlittableMarshaller<UnrealSharp.PhysicsCore.ELinearConstraintMotion>.ToNative(IntPtr.Add(ParamsBuffer, SetLinearLimits_ZMotion_Offset), 0, null, zMotion);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetLinearLimits_Limit_Offset), 0, null, limit);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetLinearLimits_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetLinearLimits_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetLinearDriveParams
    static readonly IntPtr SetLinearDriveParams_NativeFunction;
    static readonly int SetLinearDriveParams_ParamsSize;
    static readonly int SetLinearDriveParams_Accessor_Offset;
    static readonly int SetLinearDriveParams_PositionStrength_Offset;
    static readonly int SetLinearDriveParams_VelocityStrength_Offset;
    static readonly int SetLinearDriveParams_InForceLimit_Offset;
    
    public static void SetLinearDriveParams(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, float positionStrength, float velocityStrength, float inForceLimit)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetLinearDriveParams_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetLinearDriveParams_Accessor_Offset), 0, null, accessor);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetLinearDriveParams_PositionStrength_Offset), 0, null, positionStrength);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetLinearDriveParams_VelocityStrength_Offset), 0, null, velocityStrength);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetLinearDriveParams_InForceLimit_Offset), 0, null, inForceLimit);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetLinearDriveParams_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetLinearDriveParams_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetLinearBreakable
    static readonly IntPtr SetLinearBreakable_NativeFunction;
    static readonly int SetLinearBreakable_ParamsSize;
    static readonly int SetLinearBreakable_Accessor_Offset;
    static readonly int SetLinearBreakable_bLinearBreakable_Offset;
    static readonly int SetLinearBreakable_LinearBreakThreshold_Offset;
    
    public static void SetLinearBreakable(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bLinearBreakable, float linearBreakThreshold)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetLinearBreakable_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetLinearBreakable_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetLinearBreakable_bLinearBreakable_Offset), 0, null, bLinearBreakable);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetLinearBreakable_LinearBreakThreshold_Offset), 0, null, linearBreakThreshold);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetLinearBreakable_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetLinearBreakable_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetDisableCollision
    static readonly IntPtr SetDisableCollision_NativeFunction;
    static readonly int SetDisableCollision_ParamsSize;
    static readonly int SetDisableCollision_Accessor_Offset;
    static readonly int SetDisableCollision_bDisableCollision_Offset;
    
    public static void SetDisableCollision(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bDisableCollision)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetDisableCollision_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetDisableCollision_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetDisableCollision_bDisableCollision_Offset), 0, null, bDisableCollision);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetDisableCollision_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetDisableCollision_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetContactTransferScale
    static readonly IntPtr SetContactTransferScale_NativeFunction;
    static readonly int SetContactTransferScale_ParamsSize;
    static readonly int SetContactTransferScale_Accessor_Offset;
    static readonly int SetContactTransferScale_ContactTransferScale_Offset;
    
    public static void SetContactTransferScale(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, float contactTransferScale)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetContactTransferScale_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetContactTransferScale_Accessor_Offset), 0, null, accessor);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetContactTransferScale_ContactTransferScale_Offset), 0, null, contactTransferScale);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetContactTransferScale_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetContactTransferScale_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetAngularVelocityTarget
    static readonly IntPtr SetAngularVelocityTarget_NativeFunction;
    static readonly int SetAngularVelocityTarget_ParamsSize;
    static readonly int SetAngularVelocityTarget_Accessor_Offset;
    static readonly int SetAngularVelocityTarget_InVelTarget_Offset;
    
    public static void SetAngularVelocityTarget(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, System.DoubleNumerics.Vector3 inVelTarget)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetAngularVelocityTarget_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetAngularVelocityTarget_Accessor_Offset), 0, null, accessor);
            BlittableMarshaller<System.DoubleNumerics.Vector3>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularVelocityTarget_InVelTarget_Offset), 0, null, inVelTarget);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetAngularVelocityTarget_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetAngularVelocityTarget_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetAngularVelocityDriveTwistAndSwing
    static readonly IntPtr SetAngularVelocityDriveTwistAndSwing_NativeFunction;
    static readonly int SetAngularVelocityDriveTwistAndSwing_ParamsSize;
    static readonly int SetAngularVelocityDriveTwistAndSwing_Accessor_Offset;
    static readonly int SetAngularVelocityDriveTwistAndSwing_bEnableTwistDrive_Offset;
    static readonly int SetAngularVelocityDriveTwistAndSwing_bEnableSwingDrive_Offset;
    
    public static void SetAngularVelocityDriveTwistAndSwing(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bEnableTwistDrive, bool bEnableSwingDrive)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetAngularVelocityDriveTwistAndSwing_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetAngularVelocityDriveTwistAndSwing_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetAngularVelocityDriveTwistAndSwing_bEnableTwistDrive_Offset), 0, null, bEnableTwistDrive);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetAngularVelocityDriveTwistAndSwing_bEnableSwingDrive_Offset), 0, null, bEnableSwingDrive);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetAngularVelocityDriveTwistAndSwing_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetAngularVelocityDriveTwistAndSwing_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetAngularVelocityDriveSLERP
    static readonly IntPtr SetAngularVelocityDriveSLERP_NativeFunction;
    static readonly int SetAngularVelocityDriveSLERP_ParamsSize;
    static readonly int SetAngularVelocityDriveSLERP_Accessor_Offset;
    static readonly int SetAngularVelocityDriveSLERP_bEnableSLERP_Offset;
    
    public static void SetAngularVelocityDriveSLERP(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bEnableSLERP)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetAngularVelocityDriveSLERP_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetAngularVelocityDriveSLERP_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetAngularVelocityDriveSLERP_bEnableSLERP_Offset), 0, null, bEnableSLERP);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetAngularVelocityDriveSLERP_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetAngularVelocityDriveSLERP_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetAngularSoftTwistLimitParams
    static readonly IntPtr SetAngularSoftTwistLimitParams_NativeFunction;
    static readonly int SetAngularSoftTwistLimitParams_ParamsSize;
    static readonly int SetAngularSoftTwistLimitParams_Accessor_Offset;
    static readonly int SetAngularSoftTwistLimitParams_bSoftTwistLimit_Offset;
    static readonly int SetAngularSoftTwistLimitParams_TwistLimitStiffness_Offset;
    static readonly int SetAngularSoftTwistLimitParams_TwistLimitDamping_Offset;
    static readonly int SetAngularSoftTwistLimitParams_TwistLimitRestitution_Offset;
    static readonly int SetAngularSoftTwistLimitParams_TwistLimitContactDistance_Offset;
    
    public static void SetAngularSoftTwistLimitParams(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bSoftTwistLimit, float twistLimitStiffness, float twistLimitDamping, float twistLimitRestitution, float twistLimitContactDistance)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetAngularSoftTwistLimitParams_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetAngularSoftTwistLimitParams_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetAngularSoftTwistLimitParams_bSoftTwistLimit_Offset), 0, null, bSoftTwistLimit);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularSoftTwistLimitParams_TwistLimitStiffness_Offset), 0, null, twistLimitStiffness);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularSoftTwistLimitParams_TwistLimitDamping_Offset), 0, null, twistLimitDamping);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularSoftTwistLimitParams_TwistLimitRestitution_Offset), 0, null, twistLimitRestitution);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularSoftTwistLimitParams_TwistLimitContactDistance_Offset), 0, null, twistLimitContactDistance);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetAngularSoftTwistLimitParams_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetAngularSoftTwistLimitParams_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetAngularSoftSwingLimitParams
    static readonly IntPtr SetAngularSoftSwingLimitParams_NativeFunction;
    static readonly int SetAngularSoftSwingLimitParams_ParamsSize;
    static readonly int SetAngularSoftSwingLimitParams_Accessor_Offset;
    static readonly int SetAngularSoftSwingLimitParams_bSoftSwingLimit_Offset;
    static readonly int SetAngularSoftSwingLimitParams_SwingLimitStiffness_Offset;
    static readonly int SetAngularSoftSwingLimitParams_SwingLimitDamping_Offset;
    static readonly int SetAngularSoftSwingLimitParams_SwingLimitRestitution_Offset;
    static readonly int SetAngularSoftSwingLimitParams_SwingLimitContactDistance_Offset;
    
    public static void SetAngularSoftSwingLimitParams(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bSoftSwingLimit, float swingLimitStiffness, float swingLimitDamping, float swingLimitRestitution, float swingLimitContactDistance)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetAngularSoftSwingLimitParams_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetAngularSoftSwingLimitParams_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetAngularSoftSwingLimitParams_bSoftSwingLimit_Offset), 0, null, bSoftSwingLimit);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularSoftSwingLimitParams_SwingLimitStiffness_Offset), 0, null, swingLimitStiffness);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularSoftSwingLimitParams_SwingLimitDamping_Offset), 0, null, swingLimitDamping);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularSoftSwingLimitParams_SwingLimitRestitution_Offset), 0, null, swingLimitRestitution);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularSoftSwingLimitParams_SwingLimitContactDistance_Offset), 0, null, swingLimitContactDistance);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetAngularSoftSwingLimitParams_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetAngularSoftSwingLimitParams_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetAngularPlasticity
    static readonly IntPtr SetAngularPlasticity_NativeFunction;
    static readonly int SetAngularPlasticity_ParamsSize;
    static readonly int SetAngularPlasticity_Accessor_Offset;
    static readonly int SetAngularPlasticity_bAngularPlasticity_Offset;
    static readonly int SetAngularPlasticity_AngularPlasticityThreshold_Offset;
    
    public static void SetAngularPlasticity(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bAngularPlasticity, float angularPlasticityThreshold)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetAngularPlasticity_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetAngularPlasticity_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetAngularPlasticity_bAngularPlasticity_Offset), 0, null, bAngularPlasticity);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularPlasticity_AngularPlasticityThreshold_Offset), 0, null, angularPlasticityThreshold);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetAngularPlasticity_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetAngularPlasticity_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetAngularOrientationTarget
    static readonly IntPtr SetAngularOrientationTarget_NativeFunction;
    static readonly int SetAngularOrientationTarget_ParamsSize;
    static readonly int SetAngularOrientationTarget_Accessor_Offset;
    static readonly int SetAngularOrientationTarget_InPosTarget_Offset;
    
    public static void SetAngularOrientationTarget(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, UnrealSharp.Rotator inPosTarget)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetAngularOrientationTarget_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetAngularOrientationTarget_Accessor_Offset), 0, null, accessor);
            BlittableMarshaller<UnrealSharp.Rotator>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularOrientationTarget_InPosTarget_Offset), 0, null, inPosTarget);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetAngularOrientationTarget_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetAngularOrientationTarget_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetAngularLimits
    static readonly IntPtr SetAngularLimits_NativeFunction;
    static readonly int SetAngularLimits_ParamsSize;
    static readonly int SetAngularLimits_Accessor_Offset;
    static readonly int SetAngularLimits_Swing1MotionType_Offset;
    static readonly int SetAngularLimits_Swing1LimitAngle_Offset;
    static readonly int SetAngularLimits_Swing2MotionType_Offset;
    static readonly int SetAngularLimits_Swing2LimitAngle_Offset;
    static readonly int SetAngularLimits_TwistMotionType_Offset;
    static readonly int SetAngularLimits_TwistLimitAngle_Offset;
    
    public static void SetAngularLimits(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, UnrealSharp.PhysicsCore.EAngularConstraintMotion swing1MotionType, float swing1LimitAngle, UnrealSharp.PhysicsCore.EAngularConstraintMotion swing2MotionType, float swing2LimitAngle, UnrealSharp.PhysicsCore.EAngularConstraintMotion twistMotionType, float twistLimitAngle)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetAngularLimits_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetAngularLimits_Accessor_Offset), 0, null, accessor);
            BlittableMarshaller<UnrealSharp.PhysicsCore.EAngularConstraintMotion>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularLimits_Swing1MotionType_Offset), 0, null, swing1MotionType);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularLimits_Swing1LimitAngle_Offset), 0, null, swing1LimitAngle);
            BlittableMarshaller<UnrealSharp.PhysicsCore.EAngularConstraintMotion>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularLimits_Swing2MotionType_Offset), 0, null, swing2MotionType);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularLimits_Swing2LimitAngle_Offset), 0, null, swing2LimitAngle);
            BlittableMarshaller<UnrealSharp.PhysicsCore.EAngularConstraintMotion>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularLimits_TwistMotionType_Offset), 0, null, twistMotionType);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularLimits_TwistLimitAngle_Offset), 0, null, twistLimitAngle);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetAngularLimits_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetAngularLimits_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetAngularDriveParams
    static readonly IntPtr SetAngularDriveParams_NativeFunction;
    static readonly int SetAngularDriveParams_ParamsSize;
    static readonly int SetAngularDriveParams_Accessor_Offset;
    static readonly int SetAngularDriveParams_PositionStrength_Offset;
    static readonly int SetAngularDriveParams_VelocityStrength_Offset;
    static readonly int SetAngularDriveParams_InForceLimit_Offset;
    
    public static void SetAngularDriveParams(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, float positionStrength, float velocityStrength, float inForceLimit)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetAngularDriveParams_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetAngularDriveParams_Accessor_Offset), 0, null, accessor);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularDriveParams_PositionStrength_Offset), 0, null, positionStrength);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularDriveParams_VelocityStrength_Offset), 0, null, velocityStrength);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularDriveParams_InForceLimit_Offset), 0, null, inForceLimit);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetAngularDriveParams_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetAngularDriveParams_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetAngularDriveMode
    static readonly IntPtr SetAngularDriveMode_NativeFunction;
    static readonly int SetAngularDriveMode_ParamsSize;
    static readonly int SetAngularDriveMode_Accessor_Offset;
    static readonly int SetAngularDriveMode_DriveMode_Offset;
    
    public static void SetAngularDriveMode(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, UnrealSharp.Engine.EAngularDriveMode driveMode)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetAngularDriveMode_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetAngularDriveMode_Accessor_Offset), 0, null, accessor);
            BlittableMarshaller<UnrealSharp.Engine.EAngularDriveMode>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularDriveMode_DriveMode_Offset), 0, null, driveMode);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetAngularDriveMode_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetAngularDriveMode_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:SetAngularBreakable
    static readonly IntPtr SetAngularBreakable_NativeFunction;
    static readonly int SetAngularBreakable_ParamsSize;
    static readonly int SetAngularBreakable_Accessor_Offset;
    static readonly int SetAngularBreakable_bAngularBreakable_Offset;
    static readonly int SetAngularBreakable_AngularBreakThreshold_Offset;
    
    public static void SetAngularBreakable(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, bool bAngularBreakable, float angularBreakThreshold)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[SetAngularBreakable_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, SetAngularBreakable_Accessor_Offset), 0, null, accessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, SetAngularBreakable_bAngularBreakable_Offset), 0, null, bAngularBreakable);
            BlittableMarshaller<float>.ToNative(IntPtr.Add(ParamsBuffer, SetAngularBreakable_AngularBreakThreshold_Offset), 0, null, angularBreakThreshold);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, SetAngularBreakable_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, SetAngularBreakable_Accessor_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetProjectionParams
    static readonly IntPtr GetProjectionParams_NativeFunction;
    static readonly int GetProjectionParams_ParamsSize;
    static readonly int GetProjectionParams_Accessor_Offset;
    static readonly int GetProjectionParams_bEnableProjection_Offset;
    static readonly int GetProjectionParams_ProjectionLinearAlpha_Offset;
    static readonly int GetProjectionParams_ProjectionAngularAlpha_Offset;
    
    public static void GetProjectionParams(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out bool bEnableProjection, out float projectionLinearAlpha, out float projectionAngularAlpha)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetProjectionParams_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetProjectionParams_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetProjectionParams_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetProjectionParams_Accessor_Offset), 0, null);
            bEnableProjection = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetProjectionParams_bEnableProjection_Offset), 0, null);
            projectionLinearAlpha = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetProjectionParams_ProjectionLinearAlpha_Offset), 0, null);
            projectionAngularAlpha = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetProjectionParams_ProjectionAngularAlpha_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetParentDominates
    static readonly IntPtr GetParentDominates_NativeFunction;
    static readonly int GetParentDominates_ParamsSize;
    static readonly int GetParentDominates_Accessor_Offset;
    static readonly int GetParentDominates_ReturnValue_Offset;
    
    public static bool GetParentDominates(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetParentDominates_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetParentDominates_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetParentDominates_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetParentDominates_Accessor_Offset), 0, null);
            bool returnValue;
            returnValue = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetParentDominates_ReturnValue_Offset), 0, null);
            
            return returnValue;
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetOrientationDriveTwistAndSwing
    static readonly IntPtr GetOrientationDriveTwistAndSwing_NativeFunction;
    static readonly int GetOrientationDriveTwistAndSwing_ParamsSize;
    static readonly int GetOrientationDriveTwistAndSwing_Accessor_Offset;
    static readonly int GetOrientationDriveTwistAndSwing_bOutEnableTwistDrive_Offset;
    static readonly int GetOrientationDriveTwistAndSwing_bOutEnableSwingDrive_Offset;
    
    public static void GetOrientationDriveTwistAndSwing(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out bool bOutEnableTwistDrive, out bool bOutEnableSwingDrive)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetOrientationDriveTwistAndSwing_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetOrientationDriveTwistAndSwing_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetOrientationDriveTwistAndSwing_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetOrientationDriveTwistAndSwing_Accessor_Offset), 0, null);
            bOutEnableTwistDrive = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetOrientationDriveTwistAndSwing_bOutEnableTwistDrive_Offset), 0, null);
            bOutEnableSwingDrive = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetOrientationDriveTwistAndSwing_bOutEnableSwingDrive_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetOrientationDriveSLERP
    static readonly IntPtr GetOrientationDriveSLERP_NativeFunction;
    static readonly int GetOrientationDriveSLERP_ParamsSize;
    static readonly int GetOrientationDriveSLERP_Accessor_Offset;
    static readonly int GetOrientationDriveSLERP_bOutEnableSLERP_Offset;
    
    public static void GetOrientationDriveSLERP(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out bool bOutEnableSLERP)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetOrientationDriveSLERP_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetOrientationDriveSLERP_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetOrientationDriveSLERP_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetOrientationDriveSLERP_Accessor_Offset), 0, null);
            bOutEnableSLERP = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetOrientationDriveSLERP_bOutEnableSLERP_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetMassConditioningEnabled
    static readonly IntPtr GetMassConditioningEnabled_NativeFunction;
    static readonly int GetMassConditioningEnabled_ParamsSize;
    static readonly int GetMassConditioningEnabled_Accessor_Offset;
    static readonly int GetMassConditioningEnabled_ReturnValue_Offset;
    
    public static bool GetMassConditioningEnabled(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetMassConditioningEnabled_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetMassConditioningEnabled_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetMassConditioningEnabled_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetMassConditioningEnabled_Accessor_Offset), 0, null);
            bool returnValue;
            returnValue = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetMassConditioningEnabled_ReturnValue_Offset), 0, null);
            
            return returnValue;
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetLinearVelocityTarget
    static readonly IntPtr GetLinearVelocityTarget_NativeFunction;
    static readonly int GetLinearVelocityTarget_ParamsSize;
    static readonly int GetLinearVelocityTarget_Accessor_Offset;
    static readonly int GetLinearVelocityTarget_OutVelTarget_Offset;
    
    public static void GetLinearVelocityTarget(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out System.DoubleNumerics.Vector3 outVelTarget)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetLinearVelocityTarget_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetLinearVelocityTarget_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetLinearVelocityTarget_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetLinearVelocityTarget_Accessor_Offset), 0, null);
            outVelTarget = BlittableMarshaller<System.DoubleNumerics.Vector3>.FromNative(IntPtr.Add(ParamsBuffer, GetLinearVelocityTarget_OutVelTarget_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetLinearVelocityDrive
    static readonly IntPtr GetLinearVelocityDrive_NativeFunction;
    static readonly int GetLinearVelocityDrive_ParamsSize;
    static readonly int GetLinearVelocityDrive_Accessor_Offset;
    static readonly int GetLinearVelocityDrive_bOutEnableDriveX_Offset;
    static readonly int GetLinearVelocityDrive_bOutEnableDriveY_Offset;
    static readonly int GetLinearVelocityDrive_bOutEnableDriveZ_Offset;
    
    public static void GetLinearVelocityDrive(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out bool bOutEnableDriveX, out bool bOutEnableDriveY, out bool bOutEnableDriveZ)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetLinearVelocityDrive_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetLinearVelocityDrive_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetLinearVelocityDrive_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetLinearVelocityDrive_Accessor_Offset), 0, null);
            bOutEnableDriveX = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetLinearVelocityDrive_bOutEnableDriveX_Offset), 0, null);
            bOutEnableDriveY = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetLinearVelocityDrive_bOutEnableDriveY_Offset), 0, null);
            bOutEnableDriveZ = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetLinearVelocityDrive_bOutEnableDriveZ_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetLinearSoftLimitParams
    static readonly IntPtr GetLinearSoftLimitParams_NativeFunction;
    static readonly int GetLinearSoftLimitParams_ParamsSize;
    static readonly int GetLinearSoftLimitParams_Accessor_Offset;
    static readonly int GetLinearSoftLimitParams_bSoftLinearLimit_Offset;
    static readonly int GetLinearSoftLimitParams_LinearLimitStiffness_Offset;
    static readonly int GetLinearSoftLimitParams_LinearLimitDamping_Offset;
    static readonly int GetLinearSoftLimitParams_LinearLimitRestitution_Offset;
    static readonly int GetLinearSoftLimitParams_LinearLimitContactDistance_Offset;
    
    public static void GetLinearSoftLimitParams(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out bool bSoftLinearLimit, out float linearLimitStiffness, out float linearLimitDamping, out float linearLimitRestitution, out float linearLimitContactDistance)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetLinearSoftLimitParams_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetLinearSoftLimitParams_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetLinearSoftLimitParams_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetLinearSoftLimitParams_Accessor_Offset), 0, null);
            bSoftLinearLimit = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetLinearSoftLimitParams_bSoftLinearLimit_Offset), 0, null);
            linearLimitStiffness = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetLinearSoftLimitParams_LinearLimitStiffness_Offset), 0, null);
            linearLimitDamping = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetLinearSoftLimitParams_LinearLimitDamping_Offset), 0, null);
            linearLimitRestitution = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetLinearSoftLimitParams_LinearLimitRestitution_Offset), 0, null);
            linearLimitContactDistance = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetLinearSoftLimitParams_LinearLimitContactDistance_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetLinearPositionTarget
    static readonly IntPtr GetLinearPositionTarget_NativeFunction;
    static readonly int GetLinearPositionTarget_ParamsSize;
    static readonly int GetLinearPositionTarget_Accessor_Offset;
    static readonly int GetLinearPositionTarget_OutPosTarget_Offset;
    
    public static void GetLinearPositionTarget(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out System.DoubleNumerics.Vector3 outPosTarget)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetLinearPositionTarget_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetLinearPositionTarget_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetLinearPositionTarget_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetLinearPositionTarget_Accessor_Offset), 0, null);
            outPosTarget = BlittableMarshaller<System.DoubleNumerics.Vector3>.FromNative(IntPtr.Add(ParamsBuffer, GetLinearPositionTarget_OutPosTarget_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetLinearPositionDrive
    static readonly IntPtr GetLinearPositionDrive_NativeFunction;
    static readonly int GetLinearPositionDrive_ParamsSize;
    static readonly int GetLinearPositionDrive_Accessor_Offset;
    static readonly int GetLinearPositionDrive_bOutEnableDriveX_Offset;
    static readonly int GetLinearPositionDrive_bOutEnableDriveY_Offset;
    static readonly int GetLinearPositionDrive_bOutEnableDriveZ_Offset;
    
    public static void GetLinearPositionDrive(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out bool bOutEnableDriveX, out bool bOutEnableDriveY, out bool bOutEnableDriveZ)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetLinearPositionDrive_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetLinearPositionDrive_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetLinearPositionDrive_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetLinearPositionDrive_Accessor_Offset), 0, null);
            bOutEnableDriveX = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetLinearPositionDrive_bOutEnableDriveX_Offset), 0, null);
            bOutEnableDriveY = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetLinearPositionDrive_bOutEnableDriveY_Offset), 0, null);
            bOutEnableDriveZ = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetLinearPositionDrive_bOutEnableDriveZ_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetLinearPlasticity
    static readonly IntPtr GetLinearPlasticity_NativeFunction;
    static readonly int GetLinearPlasticity_ParamsSize;
    static readonly int GetLinearPlasticity_Accessor_Offset;
    static readonly int GetLinearPlasticity_bLinearPlasticity_Offset;
    static readonly int GetLinearPlasticity_LinearPlasticityThreshold_Offset;
    static readonly int GetLinearPlasticity_PlasticityType_Offset;
    
    public static void GetLinearPlasticity(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out bool bLinearPlasticity, out float linearPlasticityThreshold, out UnrealSharp.PhysicsCore.EConstraintPlasticityType plasticityType)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetLinearPlasticity_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetLinearPlasticity_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetLinearPlasticity_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetLinearPlasticity_Accessor_Offset), 0, null);
            bLinearPlasticity = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetLinearPlasticity_bLinearPlasticity_Offset), 0, null);
            linearPlasticityThreshold = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetLinearPlasticity_LinearPlasticityThreshold_Offset), 0, null);
            plasticityType = BlittableMarshaller<UnrealSharp.PhysicsCore.EConstraintPlasticityType>.FromNative(IntPtr.Add(ParamsBuffer, GetLinearPlasticity_PlasticityType_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetLinearLimits
    static readonly IntPtr GetLinearLimits_NativeFunction;
    static readonly int GetLinearLimits_ParamsSize;
    static readonly int GetLinearLimits_Accessor_Offset;
    static readonly int GetLinearLimits_XMotion_Offset;
    static readonly int GetLinearLimits_YMotion_Offset;
    static readonly int GetLinearLimits_ZMotion_Offset;
    static readonly int GetLinearLimits_Limit_Offset;
    
    public static void GetLinearLimits(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out UnrealSharp.PhysicsCore.ELinearConstraintMotion xMotion, out UnrealSharp.PhysicsCore.ELinearConstraintMotion yMotion, out UnrealSharp.PhysicsCore.ELinearConstraintMotion zMotion, out float limit)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetLinearLimits_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetLinearLimits_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetLinearLimits_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetLinearLimits_Accessor_Offset), 0, null);
            xMotion = BlittableMarshaller<UnrealSharp.PhysicsCore.ELinearConstraintMotion>.FromNative(IntPtr.Add(ParamsBuffer, GetLinearLimits_XMotion_Offset), 0, null);
            yMotion = BlittableMarshaller<UnrealSharp.PhysicsCore.ELinearConstraintMotion>.FromNative(IntPtr.Add(ParamsBuffer, GetLinearLimits_YMotion_Offset), 0, null);
            zMotion = BlittableMarshaller<UnrealSharp.PhysicsCore.ELinearConstraintMotion>.FromNative(IntPtr.Add(ParamsBuffer, GetLinearLimits_ZMotion_Offset), 0, null);
            limit = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetLinearLimits_Limit_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetLinearDriveParams
    static readonly IntPtr GetLinearDriveParams_NativeFunction;
    static readonly int GetLinearDriveParams_ParamsSize;
    static readonly int GetLinearDriveParams_Accessor_Offset;
    static readonly int GetLinearDriveParams_OutPositionStrength_Offset;
    static readonly int GetLinearDriveParams_OutVelocityStrength_Offset;
    static readonly int GetLinearDriveParams_OutForceLimit_Offset;
    
    public static void GetLinearDriveParams(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out float outPositionStrength, out float outVelocityStrength, out float outForceLimit)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetLinearDriveParams_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetLinearDriveParams_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetLinearDriveParams_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetLinearDriveParams_Accessor_Offset), 0, null);
            outPositionStrength = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetLinearDriveParams_OutPositionStrength_Offset), 0, null);
            outVelocityStrength = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetLinearDriveParams_OutVelocityStrength_Offset), 0, null);
            outForceLimit = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetLinearDriveParams_OutForceLimit_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetLinearBreakable
    static readonly IntPtr GetLinearBreakable_NativeFunction;
    static readonly int GetLinearBreakable_ParamsSize;
    static readonly int GetLinearBreakable_Accessor_Offset;
    static readonly int GetLinearBreakable_bLinearBreakable_Offset;
    static readonly int GetLinearBreakable_LinearBreakThreshold_Offset;
    
    public static void GetLinearBreakable(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out bool bLinearBreakable, out float linearBreakThreshold)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetLinearBreakable_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetLinearBreakable_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetLinearBreakable_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetLinearBreakable_Accessor_Offset), 0, null);
            bLinearBreakable = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetLinearBreakable_bLinearBreakable_Offset), 0, null);
            linearBreakThreshold = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetLinearBreakable_LinearBreakThreshold_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetDisableCollsion
    static readonly IntPtr GetDisableCollsion_NativeFunction;
    static readonly int GetDisableCollsion_ParamsSize;
    static readonly int GetDisableCollsion_Accessor_Offset;
    static readonly int GetDisableCollsion_ReturnValue_Offset;
    
    public static bool GetDisableCollsion(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetDisableCollsion_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetDisableCollsion_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetDisableCollsion_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetDisableCollsion_Accessor_Offset), 0, null);
            bool returnValue;
            returnValue = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetDisableCollsion_ReturnValue_Offset), 0, null);
            
            return returnValue;
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetContactTransferScale
    static readonly IntPtr GetContactTransferScale_NativeFunction;
    static readonly int GetContactTransferScale_ParamsSize;
    static readonly int GetContactTransferScale_Accessor_Offset;
    static readonly int GetContactTransferScale_ContactTransferScale_Offset;
    
    public static void GetContactTransferScale(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out float contactTransferScale)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetContactTransferScale_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetContactTransferScale_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetContactTransferScale_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetContactTransferScale_Accessor_Offset), 0, null);
            contactTransferScale = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetContactTransferScale_ContactTransferScale_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetAttachedBodyNames
    static readonly IntPtr GetAttachedBodyNames_NativeFunction;
    static readonly int GetAttachedBodyNames_ParamsSize;
    static readonly int GetAttachedBodyNames_Accessor_Offset;
    static readonly int GetAttachedBodyNames_ParentBody_Offset;
    static readonly int GetAttachedBodyNames_ChildBody_Offset;
    
    public static void GetAttachedBodyNames(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out Name parentBody, out Name childBody)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetAttachedBodyNames_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetAttachedBodyNames_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetAttachedBodyNames_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetAttachedBodyNames_Accessor_Offset), 0, null);
            parentBody = BlittableMarshaller<Name>.FromNative(IntPtr.Add(ParamsBuffer, GetAttachedBodyNames_ParentBody_Offset), 0, null);
            childBody = BlittableMarshaller<Name>.FromNative(IntPtr.Add(ParamsBuffer, GetAttachedBodyNames_ChildBody_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetAngularVelocityTarget
    static readonly IntPtr GetAngularVelocityTarget_NativeFunction;
    static readonly int GetAngularVelocityTarget_ParamsSize;
    static readonly int GetAngularVelocityTarget_Accessor_Offset;
    static readonly int GetAngularVelocityTarget_OutVelTarget_Offset;
    
    public static void GetAngularVelocityTarget(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out System.DoubleNumerics.Vector3 outVelTarget)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetAngularVelocityTarget_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetAngularVelocityTarget_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetAngularVelocityTarget_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetAngularVelocityTarget_Accessor_Offset), 0, null);
            outVelTarget = BlittableMarshaller<System.DoubleNumerics.Vector3>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularVelocityTarget_OutVelTarget_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetAngularVelocityDriveTwistAndSwing
    static readonly IntPtr GetAngularVelocityDriveTwistAndSwing_NativeFunction;
    static readonly int GetAngularVelocityDriveTwistAndSwing_ParamsSize;
    static readonly int GetAngularVelocityDriveTwistAndSwing_Accessor_Offset;
    static readonly int GetAngularVelocityDriveTwistAndSwing_bOutEnableTwistDrive_Offset;
    static readonly int GetAngularVelocityDriveTwistAndSwing_bOutEnableSwingDrive_Offset;
    
    public static void GetAngularVelocityDriveTwistAndSwing(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out bool bOutEnableTwistDrive, out bool bOutEnableSwingDrive)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetAngularVelocityDriveTwistAndSwing_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetAngularVelocityDriveTwistAndSwing_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetAngularVelocityDriveTwistAndSwing_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetAngularVelocityDriveTwistAndSwing_Accessor_Offset), 0, null);
            bOutEnableTwistDrive = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetAngularVelocityDriveTwistAndSwing_bOutEnableTwistDrive_Offset), 0, null);
            bOutEnableSwingDrive = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetAngularVelocityDriveTwistAndSwing_bOutEnableSwingDrive_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetAngularVelocityDriveSLERP
    static readonly IntPtr GetAngularVelocityDriveSLERP_NativeFunction;
    static readonly int GetAngularVelocityDriveSLERP_ParamsSize;
    static readonly int GetAngularVelocityDriveSLERP_Accessor_Offset;
    static readonly int GetAngularVelocityDriveSLERP_bOutEnableSLERP_Offset;
    
    public static void GetAngularVelocityDriveSLERP(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out bool bOutEnableSLERP)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetAngularVelocityDriveSLERP_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetAngularVelocityDriveSLERP_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetAngularVelocityDriveSLERP_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetAngularVelocityDriveSLERP_Accessor_Offset), 0, null);
            bOutEnableSLERP = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetAngularVelocityDriveSLERP_bOutEnableSLERP_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetAngularSoftTwistLimitParams
    static readonly IntPtr GetAngularSoftTwistLimitParams_NativeFunction;
    static readonly int GetAngularSoftTwistLimitParams_ParamsSize;
    static readonly int GetAngularSoftTwistLimitParams_Accessor_Offset;
    static readonly int GetAngularSoftTwistLimitParams_bSoftTwistLimit_Offset;
    static readonly int GetAngularSoftTwistLimitParams_TwistLimitStiffness_Offset;
    static readonly int GetAngularSoftTwistLimitParams_TwistLimitDamping_Offset;
    static readonly int GetAngularSoftTwistLimitParams_TwistLimitRestitution_Offset;
    static readonly int GetAngularSoftTwistLimitParams_TwistLimitContactDistance_Offset;
    
    public static void GetAngularSoftTwistLimitParams(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out bool bSoftTwistLimit, out float twistLimitStiffness, out float twistLimitDamping, out float twistLimitRestitution, out float twistLimitContactDistance)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetAngularSoftTwistLimitParams_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetAngularSoftTwistLimitParams_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetAngularSoftTwistLimitParams_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetAngularSoftTwistLimitParams_Accessor_Offset), 0, null);
            bSoftTwistLimit = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetAngularSoftTwistLimitParams_bSoftTwistLimit_Offset), 0, null);
            twistLimitStiffness = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularSoftTwistLimitParams_TwistLimitStiffness_Offset), 0, null);
            twistLimitDamping = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularSoftTwistLimitParams_TwistLimitDamping_Offset), 0, null);
            twistLimitRestitution = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularSoftTwistLimitParams_TwistLimitRestitution_Offset), 0, null);
            twistLimitContactDistance = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularSoftTwistLimitParams_TwistLimitContactDistance_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetAngularSoftSwingLimitParams
    static readonly IntPtr GetAngularSoftSwingLimitParams_NativeFunction;
    static readonly int GetAngularSoftSwingLimitParams_ParamsSize;
    static readonly int GetAngularSoftSwingLimitParams_Accessor_Offset;
    static readonly int GetAngularSoftSwingLimitParams_bSoftSwingLimit_Offset;
    static readonly int GetAngularSoftSwingLimitParams_SwingLimitStiffness_Offset;
    static readonly int GetAngularSoftSwingLimitParams_SwingLimitDamping_Offset;
    static readonly int GetAngularSoftSwingLimitParams_SwingLimitRestitution_Offset;
    static readonly int GetAngularSoftSwingLimitParams_SwingLimitContactDistance_Offset;
    
    public static void GetAngularSoftSwingLimitParams(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out bool bSoftSwingLimit, out float swingLimitStiffness, out float swingLimitDamping, out float swingLimitRestitution, out float swingLimitContactDistance)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetAngularSoftSwingLimitParams_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetAngularSoftSwingLimitParams_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetAngularSoftSwingLimitParams_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetAngularSoftSwingLimitParams_Accessor_Offset), 0, null);
            bSoftSwingLimit = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetAngularSoftSwingLimitParams_bSoftSwingLimit_Offset), 0, null);
            swingLimitStiffness = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularSoftSwingLimitParams_SwingLimitStiffness_Offset), 0, null);
            swingLimitDamping = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularSoftSwingLimitParams_SwingLimitDamping_Offset), 0, null);
            swingLimitRestitution = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularSoftSwingLimitParams_SwingLimitRestitution_Offset), 0, null);
            swingLimitContactDistance = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularSoftSwingLimitParams_SwingLimitContactDistance_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetAngularPlasticity
    static readonly IntPtr GetAngularPlasticity_NativeFunction;
    static readonly int GetAngularPlasticity_ParamsSize;
    static readonly int GetAngularPlasticity_Accessor_Offset;
    static readonly int GetAngularPlasticity_bAngularPlasticity_Offset;
    static readonly int GetAngularPlasticity_AngularPlasticityThreshold_Offset;
    
    public static void GetAngularPlasticity(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out bool bAngularPlasticity, out float angularPlasticityThreshold)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetAngularPlasticity_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetAngularPlasticity_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetAngularPlasticity_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetAngularPlasticity_Accessor_Offset), 0, null);
            bAngularPlasticity = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetAngularPlasticity_bAngularPlasticity_Offset), 0, null);
            angularPlasticityThreshold = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularPlasticity_AngularPlasticityThreshold_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetAngularOrientationTarget
    static readonly IntPtr GetAngularOrientationTarget_NativeFunction;
    static readonly int GetAngularOrientationTarget_ParamsSize;
    static readonly int GetAngularOrientationTarget_Accessor_Offset;
    static readonly int GetAngularOrientationTarget_OutPosTarget_Offset;
    
    public static void GetAngularOrientationTarget(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out UnrealSharp.Rotator outPosTarget)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetAngularOrientationTarget_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetAngularOrientationTarget_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetAngularOrientationTarget_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetAngularOrientationTarget_Accessor_Offset), 0, null);
            outPosTarget = BlittableMarshaller<UnrealSharp.Rotator>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularOrientationTarget_OutPosTarget_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetAngularLimits
    static readonly IntPtr GetAngularLimits_NativeFunction;
    static readonly int GetAngularLimits_ParamsSize;
    static readonly int GetAngularLimits_Accessor_Offset;
    static readonly int GetAngularLimits_Swing1MotionType_Offset;
    static readonly int GetAngularLimits_Swing1LimitAngle_Offset;
    static readonly int GetAngularLimits_Swing2MotionType_Offset;
    static readonly int GetAngularLimits_Swing2LimitAngle_Offset;
    static readonly int GetAngularLimits_TwistMotionType_Offset;
    static readonly int GetAngularLimits_TwistLimitAngle_Offset;
    
    public static void GetAngularLimits(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out UnrealSharp.PhysicsCore.EAngularConstraintMotion swing1MotionType, out float swing1LimitAngle, out UnrealSharp.PhysicsCore.EAngularConstraintMotion swing2MotionType, out float swing2LimitAngle, out UnrealSharp.PhysicsCore.EAngularConstraintMotion twistMotionType, out float twistLimitAngle)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetAngularLimits_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetAngularLimits_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetAngularLimits_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetAngularLimits_Accessor_Offset), 0, null);
            swing1MotionType = BlittableMarshaller<UnrealSharp.PhysicsCore.EAngularConstraintMotion>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularLimits_Swing1MotionType_Offset), 0, null);
            swing1LimitAngle = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularLimits_Swing1LimitAngle_Offset), 0, null);
            swing2MotionType = BlittableMarshaller<UnrealSharp.PhysicsCore.EAngularConstraintMotion>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularLimits_Swing2MotionType_Offset), 0, null);
            swing2LimitAngle = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularLimits_Swing2LimitAngle_Offset), 0, null);
            twistMotionType = BlittableMarshaller<UnrealSharp.PhysicsCore.EAngularConstraintMotion>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularLimits_TwistMotionType_Offset), 0, null);
            twistLimitAngle = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularLimits_TwistLimitAngle_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetAngularDriveParams
    static readonly IntPtr GetAngularDriveParams_NativeFunction;
    static readonly int GetAngularDriveParams_ParamsSize;
    static readonly int GetAngularDriveParams_Accessor_Offset;
    static readonly int GetAngularDriveParams_OutPositionStrength_Offset;
    static readonly int GetAngularDriveParams_OutVelocityStrength_Offset;
    static readonly int GetAngularDriveParams_OutForceLimit_Offset;
    
    public static void GetAngularDriveParams(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out float outPositionStrength, out float outVelocityStrength, out float outForceLimit)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetAngularDriveParams_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetAngularDriveParams_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetAngularDriveParams_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetAngularDriveParams_Accessor_Offset), 0, null);
            outPositionStrength = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularDriveParams_OutPositionStrength_Offset), 0, null);
            outVelocityStrength = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularDriveParams_OutVelocityStrength_Offset), 0, null);
            outForceLimit = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularDriveParams_OutForceLimit_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetAngularDriveMode
    static readonly IntPtr GetAngularDriveMode_NativeFunction;
    static readonly int GetAngularDriveMode_ParamsSize;
    static readonly int GetAngularDriveMode_Accessor_Offset;
    static readonly int GetAngularDriveMode_OutDriveMode_Offset;
    
    public static void GetAngularDriveMode(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out UnrealSharp.Engine.EAngularDriveMode outDriveMode)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetAngularDriveMode_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetAngularDriveMode_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetAngularDriveMode_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetAngularDriveMode_Accessor_Offset), 0, null);
            outDriveMode = BlittableMarshaller<UnrealSharp.Engine.EAngularDriveMode>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularDriveMode_OutDriveMode_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:GetAngularBreakable
    static readonly IntPtr GetAngularBreakable_NativeFunction;
    static readonly int GetAngularBreakable_ParamsSize;
    static readonly int GetAngularBreakable_Accessor_Offset;
    static readonly int GetAngularBreakable_bAngularBreakable_Offset;
    static readonly int GetAngularBreakable_AngularBreakThreshold_Offset;
    
    public static void GetAngularBreakable(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, out bool bAngularBreakable, out float angularBreakThreshold)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[GetAngularBreakable_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, GetAngularBreakable_Accessor_Offset), 0, null, accessor);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, GetAngularBreakable_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, GetAngularBreakable_Accessor_Offset), 0, null);
            bAngularBreakable = BoolMarshaller.FromNative(IntPtr.Add(ParamsBuffer, GetAngularBreakable_bAngularBreakable_Offset), 0, null);
            angularBreakThreshold = BlittableMarshaller<float>.FromNative(IntPtr.Add(ParamsBuffer, GetAngularBreakable_AngularBreakThreshold_Offset), 0, null);
            
        }
    }
    
    // Function /Script/Engine.ConstraintInstanceBlueprintLibrary:CopyParams
    static readonly IntPtr CopyParams_NativeFunction;
    static readonly int CopyParams_ParamsSize;
    static readonly int CopyParams_Accessor_Offset;
    static readonly int CopyParams_SourceAccessor_Offset;
    static readonly int CopyParams_bKeepPosition_Offset;
    static readonly int CopyParams_bKeepRotation_Offset;
    
    public static void CopyParams(ref UnrealSharp.Engine.ConstraintInstanceAccessor accessor, ref UnrealSharp.Engine.ConstraintInstanceAccessor sourceAccessor, bool bKeepPosition = true, bool bKeepRotation = true)
    {
        unsafe
        {
            byte* ParamsBufferAllocation = stackalloc byte[CopyParams_ParamsSize];
            nint ParamsBuffer = (IntPtr) ParamsBufferAllocation;
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, CopyParams_Accessor_Offset), 0, null, accessor);
            UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.ToNative(IntPtr.Add(ParamsBuffer, CopyParams_SourceAccessor_Offset), 0, null, sourceAccessor);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, CopyParams_bKeepPosition_Offset), 0, null, bKeepPosition);
            BoolMarshaller.ToNative(IntPtr.Add(ParamsBuffer, CopyParams_bKeepRotation_Offset), 0, null, bKeepRotation);
            
            UObjectExporter.CallInvokeNativeStaticFunction(NativeClassPtr, CopyParams_NativeFunction, ParamsBuffer);
            
            accessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, CopyParams_Accessor_Offset), 0, null);
            sourceAccessor = UnrealSharp.Engine.ConstraintInstanceAccessorMarshaler.FromNative(IntPtr.Add(ParamsBuffer, CopyParams_SourceAccessor_Offset), 0, null);
            
        }
    }
    
    
}